<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
    <style>
        body {
            padding: 100px;
            width: 1000px;
            margin: auto;
            text-align: left;
            font-weight: 300;
            font-family: 'Open Sans', sans-serif;
            color: #121212;
        }

        h1,
        h2,
        h3,
        h4 {
            font-family: 'Source Sans Pro', sans-serif;
        }
    </style>
    <title>CS 184 Mesh Editor</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet" />
</head>


<body>

    <h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2022</h1>
    <h1 align="middle">Project 2: Mesh Editor</h1>
    <h2 align="middle">Hao Jie Zhou, CS184-SP22</h2>

    <br /><br />

          <div>

              <h2 align="middle">Overview</h2>
              <p>
                  Give a high-level overview of what you implemented in this project. Think about what you've built as a whole.
                  Share your thoughts on what interesting things you've learned from completing the project.
              </p>



              <h2 align="middle">Section I: Bezier Curves and Surfaces</h2>

              <!--------------------------------------------- PART 1 ----------------------------------------------->
              <h3 align="middle">Part 1: Bezier curves with 1D de Casteljau subdivision</h3>
              <p>
                  De Casteljau's Algorithm is one way to generate Bezier curves. Given n control points and some value t (between 0.0 and 1.0),
                  we are able to generate a point for each value of t that lies on a curve defined by the control points. <br /> <br />

                  To implement de Casteljau's Algorithm, we need to start with the original set of control points.
                  For a given set P containing n amount of control points, P[0] and P[n-1] define the starting and ending positions of the curve.
                  Every point is used to define the curve, but points between P[0] and P[n-1] may not necessarily lie on the curve.
                  De Casteljau's algorithm recursively generates smaller sets of intermediate points through iterations using value t. <br /> <br />

                  In each iteration with k amount of points in the current set,
                  we sequentially take point i and point i + 1 for i in (0 through k-2) and linearly interpolate between the two points using t to obtain a new point.
                  The next iteration will recurse with the k-1 points we just obtained and this procedure will repeat until we eventually obtain a single final point. <br /> <br />

                  Finally, we combine all final points generated by de Casteljau from the same set of control points over all continuous values of t to obtain the entire curve.
              </p>
              <h4>
                  Example
              </h4>
              <p>
                  Here is an example of de Casteljau's algorithm evaluated step-by-step on six original points (white) until a single final point (red) that lies on the curve is evaluated for any given t value, which is 0.5 in this case.
                  If we repeat this algorithm for all values of t between 0.0 and 1.0, then the green curve will be obtained.
              </p>

              <div align="middle">
                  <table style="width=100%">
                      <tr>
                          <td>
                              <img src="images/image1.png" align="middle" width="400px" />
                              <figcaption align="middle">Step 0</figcaption>
                          </td>
                          <td>
                              <img src="images/image2.png" align="middle" width="400px" />
                              <figcaption align="middle">Step 1</figcaption>
                          </td>
                      </tr>
                      <tr>
                          <td>
                              <img src="images/image3.png" align="middle" width="400px" />
                              <figcaption align="middle">Step 2</figcaption>
                          </td>
                          <td>
                              <img src="images/image4.png" align="middle" width="400px" />
                              <figcaption align="middle">Step 3</figcaption>
                          </td>
                      </tr>
                      <tr>
                          <td>
                              <img src="images/image5.png" align="middle" width="400px" />
                              <figcaption align="middle">Step 4</figcaption>
                          </td>
                          <td>
                              <img src="images/image6.png" align="middle" width="400px" />
                              <figcaption align="middle">Step 5 (Final)</figcaption>
                          </td>
                      </tr>
                  </table>
              </div>

              <p>
                  If we move the original control points and modify t,
                  we can see the difference how it generates different intermediate points thus resulting in a different final point which also lies on the respective curve that it creates.
              </p>

              <div align="middle">
                  <table style="width=100%">
                      <tr>
                          <td>
                              <img src="images/image7.png" align="middle" width="400px" />
                              <figcaption align="middle">de Casteljau on shifted points and different t</figcaption>
                          </td>
                      </tr>
                  </table>
              </div>



              <!--------------------------------------------- PART 2 ----------------------------------------------->
              <h3 align="middle">Part 2: Bezier surfaces with separable 1D de Casteljau subdivision</h3>
              <p>
                  Casteljau's Algorithm extends to Bezier surfaces because we can apply the same procedure to interpolate between sets of 1D curves by using points on each curve.
                  This would return to us a 2D structure. <br /> <br />
                  To implement, recall from Part 1 that de Casteljau's algorithm takes n control points and generates a 1D curve.
                  Now if we have m amount of 1D curves and take a point proportional to some value u between 0.0 and 1.0 from each of those curves,
                  then we have a new set of m control points that we can apply de Casteljau's algorithm to.
                  If we apply de Casteljau's algorithm over values v between 0.0 and 1.0 to the m points obtained from the original 1D curves for each value u,
                  we obtain a Bezier surface. <br /><br />
              </p>
              <h4>
                  Example
              </h4>
              <p>
                  Here, we can see a teapot made of several Bezier surfaces which are each in turn made from Bezier curves.
              </p>

              <div align="middle">
                  <table style="width=100%">
                      <tr>
                          <td>
                              <img src="images/image21.png" align="middle" width="600px" />
                              <figcaption align="middle">Teapot generated using de Castejau's Algorithm</figcaption>
                          </td>
                      </tr>
                  </table>
              </div>



              <h2 align="middle">Section II: Sampling</h2>

              <!--------------------------------------------- PART 3 ----------------------------------------------->
              <h3 align="middle">Part 3: Average normals for half-edge meshes</h3>
              <p>
                  As mentioned in lecture, per-vertex normal vectors are important for shading at the vertex and pixel frequency levels.
                  One way to generate such vectors without knowing the underlying geometry is by inferring it through the normals of the surrounding faces (the faces that contain the vertex). <br /> <br />

                  For each vertex, I created the area-weighted vertex normal by traversing through every surrounding face using the half-edge data structure
                  and computing the area and normal vectors for each face by taking the cross product of (v2-v1, v3-v1) with v1, v2, v3 being the corresponding vertices
                  to get the normal and dividing the magnitude of the normal by 2 to get the area.
                  These vectors are then summed and normalized, giving us a vertex normal that is weighted by each surrounding face's area.
              </p>

              <p>
                  Here, we can see a teapot shaded with and without vertex normals.
              </p>

              <div align="middle">
                  <table style="width=100%">
                      <tr>
                          <td>
                              <img src="images/image31.png" align="middle" width="500px" />
                              <figcaption align="middle">Teapot without vertex normals (Flat Shading)</figcaption>
                          </td>
                          <td>
                              <img src="images/image32.png" align="middle" width="500px" />
                              <figcaption align="middle">Teapot with vertex normals (Phong Shading)</figcaption>
                          </td>
                      </tr>
                  </table>
              </div>
              <!--------------------------------------------- PART 4 ----------------------------------------------->
              <h3 align="middle">Part 4: Half-edge flip</h3>

              <!--------------------------------------------- PART 5 ----------------------------------------------->
              <h3 align="middle">Part 5: Half-edge split</h3>

              <!--------------------------------------------- PART 6 ----------------------------------------------->
              <h3 align="middle">Part 6: Loop subdivision for mesh upsampling</h3>



              <h2 align="middle">Section III: Optional Extra Credit</h2>
              <p>If you are not participating in the optional mesh competition, don't worry about this section!</p>

              <h3 align="middle">Part 7: Design your own mesh!</h3>
              <h3>
                  The project writeup is hosted at: https://cal-cs184-student.github.io/sp22-project-webpages-haojie626/proj2/index.html
              </h3>
          </div>

</body>

<!--
<p>
    Here is an example 2x2 gridlike structure using an HTML table. Each <b>tr</b> is a row and each <b>td</b> is a
    column in that row. You might find this useful for framing and showing your result images in an organized fashion.
</p>

<div align="middle">
    <table style="width=100%">
        <tr>
            <td>
                <img src="images/image1.png" align="middle" width="400px" />
                <figcaption align="middle">Caption goes here.</figcaption>
            </td>
            <td>
                <img src="images/image2.png" align="middle" width="400px" />
                <figcaption align="middle">Caption goes here.</figcaption>
            </td>
        </tr>
        <br />
        <tr>
            <td>
                <img src="images/image3.png" align="middle" width="400px" />
                <figcaption align="middle">Caption goes here.</figcaption>
            </td>
            <td>
                <img src="images/image4.png" align="middle" width="400px" />
                <figcaption align="middle">Caption goes here.</figcaption>
            </td>
        </tr>
    </table>
</div>
    -->

</html>